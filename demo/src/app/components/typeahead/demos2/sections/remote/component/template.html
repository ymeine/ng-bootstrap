<ng-template #instructions>
  <p>
    This demo allows you to play on the two main traits of remote data: response time (delay) and failure. Don't hesitate to experiment.
  </p>

  <p>
    The <code>Reset state</code> button in this demo is important because the <code>State</code> section shows a lot of data, and is updated quite often. Note that as for other demos, a global reset button is also available, to fully reset the demo. Here is what the values of the state correspond to:
  </p>

  <ul>
    <li><code>searching</code>: a boolean displaying <code>true</code> when a search is ongoing, <code>false</code> otherwise</li>
    <li><code>search failed</code>: a boolean displaying <code>true</code> if the latest search failed, <code>false</code> otherwise or if a new search is ongoing</li>
    <li>
      observable events: counters of events happening on the Observable associated to the current search.
      <ul>
        <li><code>next</code>: +1 anytime a search emits results</li>
        <li><code>error</code>: +1 anytime a search errors</li>
        <li><code>complete</code>: +1 anytime a search completes successfully (in practice, this mirrors the value of <code>next</code>)</li>
        <li><code>unsubscribe</code>: +1 anytime an Observable is being unsubscribed from. This happens when an Observable completes, successfully or not, but also when it is being cancelled, replaced thanks to the <ngbd-operator-popup name="switchMap"></ngbd-operator-popup> operator</li>
      </ul>
    </li>
    <li>
      current values:
      <ul>
        <li><code>value</code>: the latest received <span class="defined">results list</span>, coming from successful search or not</li>
        <li><code>error</code>: the error value when latest search failed</li>
      </ul>
    </li>
  </ul>

  <p>
    To experiment, try typing in and before the response arrives (check the configured delay), type again. You should see the <code>unsubscribe</code> counter increment, meaning that the ongoing search was cancelled in favor of a new one.
  </p>

  <p>
    Then wait a bit until a result arrives, and you should see the <code>next</code> and <code>complete</code> counters increment too, as well as <code>unsubscribe</code> again. The <code>value</code> should update with the result.
  </p>

  <p>
    Check the <code>make fail</code> check box, type again and wait. You should eventually see the counters <code>error</code> and <code>unsubscribe</code> increment. The boolean <code>search failed</code> will display <code>true</code>, <code>error</code> the error message and <code>value</code> an empty list.
  </p>

  <p>
    Try playing a bit more on your own. Don't forget that you can reset the state anytime.
  </p>

  <p>
    Throughout all those experiments, pay attention to the boolean <code>searching</code>, which updates accordingly.
  </p>
</ng-template>

<ng-template #options>
  <button
    type="button"
    class="btn btn-primary reset"
    (click)="resetOptions()"
  >
    Reset
  </button>

  <ngbd-typeahead-common-checkbox
    [(value)]="makeFail"
    label="make fail"
    id="sections-use-case-async-make-fail"
  ></ngbd-typeahead-common-checkbox>

  <div class="form-group form-inline">
    <label>response delay:&nbsp;</label>
    <input
      type="number"
      class="form-control"
      [(ngModel)]="responseDelay"
      step='100'
      min='0'
      max='5000'
    />
  </div>

  <ngbd-typeahead-common-debounce-customizer [(value)]="debounceTime"></ngbd-typeahead-common-debounce-customizer>
</ng-template>

<ng-template #instance>
  <input
    type="text"
    class="form-control"

    [(ngModel)]="model"
    [ngbTypeahead]="initializeTypeahead"
  />
</ng-template>

<ng-template #stateTemplate>
  <button
    type="button"
    class="btn btn-primary reset"
    (click)="resetState()"
  >
    Reset
  </button>

  <ng-template #booleanProperty let-name="name">
      <li>
        <span
          [ngClass]="{flash: state.get(name).animated}"
        >
        <code>{{state.get(name).label}}</code>:
          <span
            [ngStyle]="{color: state.get(name).value ? 'green' : 'red'}"
          >{{state.get(name).value ? 'yes' : 'no'}}</span>
        </span>
        </li>
  </ng-template>

  <ng-template #property let-name="name">
    <li>
      <span [ngClass]="{flash: state.get(name).animated}">
        <code>{{state.get(name).label}}</code>:
        {{state.get(name).formattedValue}}
      </span>
    </li>
  </ng-template>

  <ul>
    <ng-container *ngTemplateOutlet="booleanProperty; context: {name: 'searching'}"></ng-container>
    <ng-container *ngTemplateOutlet="booleanProperty; context: {name: 'searchFailed'}"></ng-container>
    <li>
      observable events:
      <ul>
        <ng-container *ngTemplateOutlet="property; context: {name: 'counterOnNext'}"></ng-container>
        <ng-container *ngTemplateOutlet="property; context: {name: 'counterOnError'}"></ng-container>
        <ng-container *ngTemplateOutlet="property; context: {name: 'counterOnComplete'}"></ng-container>
        <ng-container *ngTemplateOutlet="property; context: {name: 'counterOnUnsubscribe'}"></ng-container>
      </ul>
    </li>
    <li>
        current values:
        <ul>
            <ng-container *ngTemplateOutlet="property; context: {name: 'currentValue'}"></ng-container>
            <ng-container *ngTemplateOutlet="property; context: {name: 'error'}"></ng-container>
        </ul>
      </li>
  </ul>
</ng-template>

<ngbd-example2
  [section]="section"
  explanations-fragment="use-case-remote"

  [snippet-component]="snippets.component"

  [resetDemo]="resetDemo"

  [instance]="instance"
  [instructions]="instructions"
  [options]="options"
  [state]="stateTemplate"
></ngbd-example2>
