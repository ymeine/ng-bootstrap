<h5>The central piece: the Observable</h5>

<p>
  The Typeahead is designed around a single Observable, to which it subscribes in order to get an updated <span class="defined">results list</span> and update its <span class="defined">popup</span> display accordingly.
</p>



<h5>Why the Observable?</h5>

<p>
  To make two entities communicate there are many possible techniques, which we won't enumerate here.
</p>

<p>
  In the context of Angular, <em>Inputs</em> and <em>Outputs</em> are the common mean of making templates communicate with the <em>Directives</em>/<em>Components</em> they instantiate. But this is not the most practical approach when it comes to communicate often-updated and potentially asynchronous data. For that, we prefer the approach of <em>Observables</em>, designed mainly for this use case.
</p>

<p>
  It simplifies the handling of asynchronous actions and the related data processing, as well as bypasses the update of the parent template, to directly target the data of the Typeahead instance.
</p>



<h5>What is the Observable contract?</h5>

<p>
  The Typeahead expects to receive an Observable which spawns lists of items of any type, this list being the <span class="defined">results list</span> and the items being the <span class="defined">result items</span>.
</p>

<p>
  The table below shows what the Typeahead does depending on the content of the <span class="defined">results list</span> and the state of its <span class="defined">popup</span>:
</p>
<table class="matrix">
  <thead>
    <tr>
      <!-- <th><span class="defined">popup</span> \ <span class="defined">results list</span></th> -->
      <th><span class="left defined">popup</span><span class="separator"></span><span class="right defined">results list</span></th>
      <th>not empty</th>
      <th>empty</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>closed</th>
      <td>open the <span class="defined">popup</span>, fill with the list</td>
      <td>do nothing</td>
    </tr>
    <tr>
      <th>open</th>
      <td>update the <span class="defined">popup</span> with the list</td>
      <td>close the popup</td>
    </tr>
  </tbody>
</table>



<h5>How to set up the Observable?</h5>

<p>
  The Typeahead uses a directive Input to pass a callback that it will call and expect the Observable to be returned from.
</p>

<p>
  On the template side, the property used by the Typeahead to instantiate its directive is the one used to pass the input callback:
</p>

<ngbd-code [lang]="snippets.observableSetup.template.language" [code]="snippets.observableSetup.template.code" [highlightedLines]="snippets.observableSetup.template.highlightedLines"></ngbd-code>

<p>
  On the component side, the latter defines this aforementioned callback, which returns the Observable — we will detail this below, just remember it is supposed to spawn lists of items:
</p>

<ngbd-code [lang]="snippets.observableSetup.component.language" [code]="snippets.observableSetup.component.code" [highlightedLines]="snippets.observableSetup.component.highlightedLines"></ngbd-code>



<h5>The basic Observable chain</h5>

<p>
  You will learn that you can create any Observable, from any source, including events occurring on the Typeahead input, then merge them, etc. This will be detailed in another section.
</p>

<p>
  In this basic use case, we will simply use a statically defined and synchronously available set of data — color names:
</p>

<ngbd-code [lang]="snippets.data.language" [code]="snippets.data.code" [highlightedLines]="snippets.data.highlightedLines"></ngbd-code>

<p>
  You may have noticed already that the callback used to provide the Observable to the Typeahead receives a single argument: another Observable. This Observable spawns strings which correspond to the <span class="defined">search term</span>, any time the <span class="defined">input field</span> value is changed — it is reacting to the <code>input</code> event of the field.
</p>

<p>
  By leveraging the chaining feature of Observables, it becomes easier to transform the <span class="defined">search term</span> to a <span class="defined">results list</span>:
</p>

<ngbd-code [lang]="snippets.observable.mapping.language" [code]="snippets.observable.mapping.code" [highlightedLines]="snippets.observable.mapping.highlightedLines"></ngbd-code>

<p>
  In our example, we return all the colors when the <span class="defined">search term</span> is empty, otherwise we return all the colors starting with it. <ngbd-operator-popup name="map"></ngbd-operator-popup> is the perfect operator to transform an input to an output: it's a 1:1 transformation — 1 value in, 1 value out.
</p>



<h5>Debouncing</h5>

<p>
  Now we have a working example. However, even for a basic usage, we might want to put in place a mechanism to avoid updating the results too frequently, that is not every time the user changes the input in case they change it quite fast or if it is not relevant.
</p>

<p>
  So we would like to delay the search after the input changed — using let's say a timer — and only if no other changes occurred in the meantime, in which case we would reset the timer.
</p>

<p>
  This mechanism is called <em>debouncing</em>, and the <ngbd-operator-popup name="debounce"></ngbd-operator-popup> and <ngbd-operator-popup name="debounceTime"></ngbd-operator-popup> operators are the solution to this job.
</p>

<p>
  The latter is simpler and will implement a debounce with the given static time, while the former is more flexible and will determine the delay based on when the first value of the given Observable is emitted. In our simple case, <ngbd-operator-popup name="debounceTime"></ngbd-operator-popup> will be enough:
</p>

<ngbd-code [lang]="snippets.observable.debouncing.part1.language" [code]="snippets.observable.debouncing.part1.code" [highlightedLines]="snippets.observable.debouncing.part1.highlightedLines"></ngbd-code>

<p>
  That way, when the user will start changing the input, we will wait for 200ms before actually returning a list of results. If they change the input before those 200ms, we will start waiting again for 200ms, until the user stops changing the input for at least 200ms.
</p>

<p>
  This however leads to an additional issue, for which the operator <ngbd-operator-popup name="distinctUntilChanged"></ngbd-operator-popup> comes to the rescue: it will avoid triggering a search twice if the value remains the same as previously.
</p>

<p>
  With debouncing, a user could modify the input and revert its changes without leaving the time to have an actual search triggered, thanks to debouncing. But once the timer is reached, and the search needs to be done, we should avoid redoing it if the value didn't actually change eventually. That's what <ngbd-operator-popup name="distinctUntilChanged"></ngbd-operator-popup> is made for.
</p>

<ngbd-code [lang]="snippets.observable.debouncing.part2.language" [code]="snippets.observable.debouncing.part2.code" [highlightedLines]="snippets.observable.debouncing.part2.highlightedLines"></ngbd-code>

<p>
  This is important to place this operator after the debouncing! Because without the delay of the debounce, <ngbd-operator-popup name="distinctUntilChanged"></ngbd-operator-popup> would remember some inputs as if they had been processed and would therefore ignore them, even if they have actually not been processed because of the debouncing.
</p>



<h5>Demo</h5>

<p>
  Here is the corresponding demo.
</p>

<p>
  Try typing <code>b</code>, <code>bl</code> or <code>gr</code>.
</p>

<p>
  Try emptying the input to see all the colors.
</p>

<p>
  You can also try to input something wrong like <code>z</code>, to see that the popup does not open or closes (depending on if it was already open or not).
</p>

<p>
  You can also change the debounce time. Try increasing it to actually feel its effect.
</p>

<button
  type="button"
  class="btn btn-primary"
  (click)="reset()"
>
  Reset
</button>

<h6>Options</h6>

<ngbd-typeahead-common-debounce-customizer [(value)]="debounceTime"></ngbd-typeahead-common-debounce-customizer>

<h6>Typeahead</h6>

<input
  type="text"
  class="form-control"
  [(ngModel)]="model"
  [ngbTypeahead]="initializeTypeahead"
/>
