<h5>Introduction</h5>

<p>
  In the previous example, we saw that to get the whole list of colors, we had to first type something to get the popup open and only then empty the input to avoid filtering.
</p>

<p>
  This is not very intuitive nor practical. It would be better if we could open the popup with some other actions, like focusing or clicking on the input.
</p>

<p>
  If you remember the previous section, the only contract used to open/close/update the <span class="defined">popup</span> is the spawning of values from the Observable returned in the initialization function.
</p>
<p>
  Even though this initialization function provides an input Observable for convenience, it is not mandatory to use it, and it is <em>not restricted</em> to only this one: you can use any Observable, and any combination of them, as long as they return lists of items.
</p>

<h5>Opening on focus</h5>

<p>
  So let's start by making it open on focus.
</p>

<p>
  We first add an event handler on the focus event, since we want to react upon focus.
</p>

<ngbd-code [snippet]="snippets.focus.template"></ngbd-code>

<p>
  Then, we will need to convert this event into something that can be plugged into the chain of Observables.
</p>

<p>
  For that, the Subject is the solution: it is a special Observable on which we can manually push new values.
</p>

<ngbd-code [snippet]="snippets.focus.subject"></ngbd-code>

<p>
  That way, we push the current value of the input field in the <code>onFocus</code> handler. That makes us have an Observable just like the one provided in the Typeahead initialization function, except that it reacts to focus events instead of input events.
</p>

<p>
  Therefore, the next and last step is to use this Observable in the chain of Observables. For that, we will use the <ngbd-operator-popup name="merge"></ngbd-operator-popup> operator.
</p>

<ngbd-code [snippet]="snippets.focus.full"></ngbd-code>

<p>
  Now, you can see that we treat the two Observable chains — the one based on input events and the one based on focus events — differently. Indeed, processing like debouncing makes sense for input events, where the user can type fast, but not for focus events. We eventually merge them into an Observable, which spawns values to be used for immediate search.
</p>

<p>
  Now let's properly implement those Observable chains, so you can see the benefits of treating them separately.
</p>

<p>
  We will need a reference to the Typeahead instance, so let's add a template variable on it:
</p>

<ngbd-code [snippet]="snippets.focus.detail.template"></ngbd-code>

<p>
  We will then use a <code>ViewChild</code> query to get this reference and be able to call <code>isPopupOpen()</code> to check wether the Typeahead popup is open or not. We will use this in the processing pipe related to the focus event:
</p>

<ngbd-code [snippet]="snippets.focus.detail.component"></ngbd-code>

<p>
  When focusing the input, we need to make sure that the popup is not already open, otherwise we would trigger an additional search, at best useless, at worst having unwanted side effects. That's why we are using <ngbd-operator-popup name="filter"></ngbd-operator-popup> in the Observable chain of the focus event, checking if the popup is not open already.
</p>



<h5>Opening on click</h5>

<p>
  This is the exact same principle as for the focus, so let's see the example code directly.
</p>

<p>
  Template:
</p>

<ngbd-code [snippet]="snippets.click.template"></ngbd-code>

<p>
  Component:
</p>

<ngbd-code [snippet]="snippets.click.intermediateComponent"></ngbd-code>

<p>
  This is however not completely ready. Indeed, we also need to make sure that the search won't be triggered twice for a same user action.
</p>
<p>
  The case of clicking on the input is one of them: it will trigger both a <code>click</code> event and potentially a <code>focus</code> event if the input was not previously focused.
</p>
<p>
  So we will introduce a new private boolean, <code>_searching</code>, to check if a search is already ongoing, and to avoid doing it twice.
</p>

<ngbd-code [snippet]="snippets.click.component"></ngbd-code>

<p>
  To update the boolean, we wrapped the search operation with two operations using the <ngbd-operator-popup name="tap"></ngbd-operator-popup> operator: this is used to make a side effect, simply forwarding the value through the pipe. The one before sets the boolean to <code>true</code>, and the one after resets it to <code>false</code>.
</p>



<h5>Opening programatically</h5>

<p>
  The idea is the exact same, and simpler. You just have to create a new Subject, merge it along with the other Observables, and push to it whenever you want to trigger a search with a new input.
</p>




<h5>Custom input event Observable vs the one from initialization function</h5>

<p>
  As you saw, we could plug on focus and click events, and use Observables to use those as inputs for searching.
</p>
<p>
  You could therefore think that the Observable passed to the initialization function is useless, since it could be done on your side by adding another event handler, a Subject, and merging it.
</p>
<p>
  However, this input Observable is not a direct Observable on the input event, the Typeahead widget does some pre-processing and post-processing based on it, therefore it is better to plug into this one instead of creating a custom one.
</p>



<h5>Demo</h5>

<p>
  The demo below uses several sources to trigger a search:
</p>

<ul>
  <li>input event</li>
  <li>focus event</li>
  <li>click event</li>
  <li>programmatic</li>
</ul>

<p>
  Try focusing the input with the <kbd>tab</kbd> key (use the dedicated element above it), you will see the Typeahead open with all suggestions. Pay attention to the updated <code>search source</code>.
</p>

<p>
  Then start typing and see the suggestions being updated. The <code>search source</code> is updated accordingly.
</p>

<p>
  Now close the popup by pressing <kbd>escape</kbd> (to keep the focus) and click on the input: it will open again. One more time, check the value of <code>search source</code>.
</p>

<p>
  To finish with this demo, click anytime on the button whose label starts with <code>Search with term</code> and see the popup being open, and the value of <code>search source</code> changing. Note that only the content of the popup changes, not the input, so the two can be mismatching, but this is beyond the concerns of the demo.
</p>

<p>
  Feel free to experiment more: checkboxes allow the disable/enable some event sources, and the <code>Reset</code> button fully resets the demo to its initial state.
</p>



<button
  type="button"
  class="btn btn-primary"
  (click)="resetProperties()"
>
  Reset
</button>

<h6>State</h6>
<ul>
  <li><code>search source</code>: {{searchSource}}</li>
</ul>

<h6>Options</h6>

<ngbd-typeahead-common-checkbox
  [(value)]="opensOnFocus"
  label="open on focus"
  id="sections-use-case-focus-opens-on-focus"
  ></ngbd-typeahead-common-checkbox>

<ngbd-typeahead-common-checkbox
  [(value)]="opensOnClick"
  label="open on click"
  id="sections-use-case-focus-opens-on-click"
></ngbd-typeahead-common-checkbox>

<ngbd-typeahead-common-checkbox
  [(value)]="simulatesSearchDelay"
  label="simulate search delay (100ms)"
  id="sections-use-case-focus-simulates-search-delay"
></ngbd-typeahead-common-checkbox>

<ngbd-typeahead-common-debounce-customizer [(value)]="debounceTime"></ngbd-typeahead-common-debounce-customizer>

<h6>Actions</h6>

<button
  type="button"
  class="btn btn-primary"
  (click)="search('bl')"
>
  Search with search term: bl
</button>

<h6>Typeahead</h6>

<p>
  <span class="focusable" tabindex="0">
    Focus me and press <kbd>tab</kbd> to focus the Typeahead
  </span>
</p>

<input
  type="text"
  class="form-control"

  [(ngModel)]="model"
  [ngbTypeahead]="initializeTypeahead"

  #instance="ngbTypeahead"
  #input
  (focus)="onFocus($event)"
  (click)="onClick($event)"
  (blur)="onBlur($event)"
/>

<div class="go-to-example">
  <a [routerLink]="['../examples']" fragment="focus">Go to example</a>
</div>
