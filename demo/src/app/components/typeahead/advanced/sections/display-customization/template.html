<h5>Introduction</h5>

<p>
  To change a bit from data workflow management, let's talk about data model and visual display.
</p>

<h5>Result item vs Option item</h5>

<p>
  To remind you, we made a distinction between the <span class="defined">result item</span> and the <span class="defined">option item</span>. There is an important difference between the two:
</p>
<ul>
  <li>the <span class="defined">result item</span> is part of the data model, and holds the whole piece of data that you wanna keep in your program and be able to select. This can be more complex than a string.</li>
  <li>the <span class="defined">option item</span> is what is shown in the <span class="defined">popup</span>. It is a visual representation of the <span class="defined">result item</span>.</li>
</ul>

<p>
  The conversion from <span class="defined">result item</span> to <span class="defined">option item</span> for display is what we call <em>formatting</em>.
</p>



<h5>Our new data model</h5>

<p>
  To demonstrate the benefits of formatting, we need a new data model.
</p>

<p>
  To be consistent with previous use cases, we will still define colors, but add more information to each definition.
</p>

<p>Interface: </p>

<ngbd-code [snippet]="snippets.model"></ngbd-code>

<p>Data: </p>

<ngbd-code [snippet]="snippets.data"></ngbd-code>



<h5>String representation: <code>resultFormatter</code></h5>

<p>
  The <span class="defined">option item</span> can be displayed from a string. In this case, use the property <code>resultFormatter</code>.
</p>

<p>
  It expects a reference to a function taking the <span class="defined">result item</span> as input (the type depending on your use case), and returning a string as output:
</p>

<p>Pass it that way in the template: </p>

<ngbd-code [snippet]="snippets.resultFormatter.template"></ngbd-code>

<p>And define it in the component: </p>

<ngbd-code [snippet]="snippets.resultFormatter.component"></ngbd-code>

<p>
  In that case, we not only extracted the name of the color, but also the hexadecimal code to generate a more detailed representation.
</p>

<p>
  But what if a string is not enough given the complexity of the data?
</p>



<h5>Complex representation: <code>resultTemplate</code></h5>

<p>
  The <span class="defined">option item</span> can be displayed from a custom template. In that case, use the property <code>resultFormatter</code>.
</p>

<p>
  It expects a reference to a template receiving a context with the <span class="defined">result item</span> and the <span class="defined">search term</span>, respectively as <code>result</code> and <code>term</code>:
</p>

<ngbd-code [snippet]="snippets.resultTemplate.html"></ngbd-code>

<p>
  We took the opportunity of being able to output anything to display a color chip, a visual aid for the user.
</p>

<p>
  On line 2, we defined a variable to reference the template, and on line 19 we gave it to the Typeahead instance.
</p>

<p>
  Regarding the content of the template itself, on line 8 we defined the color chip, leveraging the data present in the <span class="defined">result item</span>. On line 10 we used a helper component provided by ng-bootstrap to highlight part of a word, in this case to highlight which part matched from the <span class="defined">search term</span>. On line 12, we displayed the hexadecimal code again.
</p>

<p>
  For the record, here is the associated CSS:
</p>

<ngbd-code [snippet]="snippets.resultTemplate.css"></ngbd-code>



<h5>The input field content: <code>inputFormatter</code></h5>

<p>
  Last but not least, it is also possible to customize the display of the <span class="defined">input field</span> when it must display a selected <span>result item</span>.
</p>

<p>
  There are two limitations though:
</p>
<ul>
  <li>one technical: since this is an input element, only a string representation can be used, no custom template</li>
  <li>one of design: since the <span class="defined">input field</span> is also used to edit the <span class="defined">search term</span>, altering the content of the field will change the initial value you edit for your next search. Therefore this is more suitable for simple transformations, which would lead to a value that can still be handled by the search algorithm in use.</li>
</ul>

<p>
  To format the <span class="defined">input field</span>, use the property <code>inputFormatter</code>,
</p>

<p>
  It expects a reference to a function taking the <span class="defined">result item</span> as input (the type depending on your use case), and returning a string in output:
</p>

<p>Pass it that way in the template: </p>

<ngbd-code [snippet]="snippets.inputFormatter.template"></ngbd-code>

<p>And define it in the component: </p>

<ngbd-code [snippet]="snippets.inputFormatter.component"></ngbd-code>

<p>
  You can notice it works the same way as <code>resultFormatter</code>, but we implemented a simpler formatting function to avoid the issue regarding the subsequent searches.
</p>

<div class="go-to-example">
  <a [routerLink]="['../examples']" fragment="format">Go to example: result string formatter</a>
</div>

<div class="go-to-example">
  <a [routerLink]="['../examples']" fragment="template">Go to example: result template formatter</a>
</div>
