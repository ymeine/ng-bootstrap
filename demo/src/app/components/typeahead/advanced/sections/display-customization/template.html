<h5>Introduction</h5>

<p>
  To change a bit from data workflow management, let's talk about data model and visual display.
</p>

<h5>Result item vs Option item</h5>

<p>
  To remind you, we made a distinction between the <span class="defined">result item</span> and the <span class="defined">option item</span>. There is an important difference between the two:
</p>
<ul>
  <li>the <span class="defined">result item</span> is part of the data model, and holds the whole piece of data that you wanna keep in your program and be able to select. This can be more complex than a string.</li>
  <li>the <span class="defined">option item</span> is what is shown in the <span class="defined">popup</span>. It is a visual representation of the <span class="defined">result item</span>.</li>
</ul>

<p>
  The conversion from <span class="defined">result item</span> to <span class="defined">option item</span> for display is what we call <em>formatting</em>.
</p>



<h5>Our new data model</h5>

<p>
  To demonstrate the benefits of formatting, we need a new data model.
</p>

<p>
  To be consistent with previous use cases, we will still define colors, but add more information to each definition.
</p>

<p>Interface: </p>

<ngbd-code [snippet]="snippets.model"></ngbd-code>

<p>Data: </p>

<ngbd-code [snippet]="snippets.data"></ngbd-code>



<h5>String representation: <code>resultFormatter</code></h5>

<p>
  The <span class="defined">option item</span> can be displayed from a string. In this case, use the property <code>resultFormatter</code>.
</p>

<p>
  It expects a reference to a function taking the <span class="defined">result item</span> as input (the type depending on your use case), and returning a string as output:
</p>

<p>Pass it that way in the template: </p>

<ngbd-code [snippet]="snippets.resultFormatter.template"></ngbd-code>

<p>And define it in the component: </p>

<ngbd-code [snippet]="snippets.resultFormatter.component"></ngbd-code>

<p>
  In that case, we not only extracted the name of the color, but also the hexadecimal code to generate a more detailed representation.
</p>

<p>
  But what if a string is not enough given the complexity of the data?
</p>



<h5>Complex representation: <code>resultTemplate</code></h5>

<p>
  The <span class="defined">option item</span> can be displayed from a custom template. In that case, use the property <code>resultFormatter</code>.
</p>

<p>
  It expects a reference to a template receiving a context with the <span class="defined">result item</span> and the <span class="defined">search term</span>, respectively as <code>result</code> and <code>term</code>:
</p>

<ngbd-code [snippet]="snippets.resultTemplate.html"></ngbd-code>

<p>
  We took the opportunity of being able to output anything to display a color chip, a visual aid for the user.
</p>

<p>
  On line 2, we defined a variable to reference the template, and on line 19 we gave it to the Typeahead instance.
</p>

<p>
  Regarding the content of the template itself, on line 8 we defined the color chip, leveraging the data present in the <span class="defined">result item</span>. On line 10 we used a helper component provided by ng-bootstrap to highlight part of a word, in this case to highlight which part matched from the <span class="defined">search term</span>. On line 12, we displayed the hexadecimal code again.
</p>

<p>
  For the record, here is the associated CSS:
</p>

<ngbd-code [snippet]="snippets.resultTemplate.css"></ngbd-code>



<h5>The input field content: <code>inputFormatter</code></h5>

<p>
  Last but not least, it is also possible to customize the display of the <span class="defined">input field</span> when it must display a selected <span>result item</span>.
</p>

<p>
  There are two limitations though:
</p>
<ul>
  <li>one technical: since this is an input element, only a string representation can be used, no custom template</li>
  <li>one of design: since the <span class="defined">input field</span> is also used to edit the <span class="defined">search term</span>, altering the content of the field will change the initial value you edit for your next search. Therefore this is more suitable for simple transformations, which would lead to a value that can still be handled by the search algorithm in use.</li>
</ul>

<p>
  To format the <span class="defined">input field</span>, use the property <code>inputFormatter</code>,
</p>

<p>
  It expects a reference to a function taking the <span class="defined">result item</span> as input (the type depending on your use case), and returning a string in output:
</p>

<p>Pass it that way in the template: </p>

<ngbd-code [snippet]="snippets.inputFormatter.template"></ngbd-code>

<p>And define it in the component: </p>

<ngbd-code [snippet]="snippets.inputFormatter.component"></ngbd-code>

<p>
  You can notice it works the same way as <code>resultFormatter</code>, but we implemented a simpler formatting function to avoid the issue regarding the subsequent searches.
</p>



<h5>Demo</h5>

<p>
  Here is the demo corresponding to what we implemented above.
</p>

<p>
  Choose between the simple string formatter or the template rendering (default) and observe the difference.
</p>

<p>
  Choose an option from the <span class="defined">options list</span>, and see how the name of the color is set to upper case in the input. Try disabling it with the checkbox, and choose again an option. See the difference.
</p>

<p>
  In all cases formatters are needed since the input data model contains objects, nothing that can be displayed as is in a user interface.
</p>

<button
  type="button"
  class="btn btn-primary"
  (click)="reset()"
>
  Reset
</button>

<h6>Options</h6>

<div class="form-check">
  <input
    class="form-check-input"
    type="radio"
    [(ngModel)]="resultTransformationType"
    value="formatter"
    [ngModelOptions]="{standalone: true}"
    id="typeahead-overview-sections-use-case-customization-use-formatter"
  />
  <label
    class="form-check-label"
    for="typeahead-overview-sections-use-case-customization-use-formatter"
  >
    use custom formatter for options list
  </label>
</div>

<div class="form-check">
  <input
    class="form-check-input"
    type="radio"
    [(ngModel)]="resultTransformationType"
    value="template"
    [ngModelOptions]="{standalone: true}"
    id="typeahead-overview-sections-use-case-customization-use-template"
  />
  <label
    class="form-check-label"
    for="typeahead-overview-sections-use-case-customization-use-template"
  >
    use custom template for options list
  </label>
</div>

<ngbd-typeahead-common-checkbox
  [(value)]="formatUpperCase"
  label="format input to upper case"
  id="sections-use-case-customization-use-input-formatter"
></ngbd-typeahead-common-checkbox>

<ngbd-typeahead-common-debounce-customizer [(value)]="debounceTime"></ngbd-typeahead-common-debounce-customizer>

<ng-template
  #displayResult
  let-color="result"
  let-term="term"
>
  <div class="middle">
    <div class="color-chip" [ngStyle]="{'background-color': '#' + color.hexCode}"></div>
    <ngb-highlight [result]="color.name" [term]="term"></ngb-highlight><span> ({{color.hexCode}})</span>
  </div>
</ng-template>

<h6>Typeahead</h6>

<input
  type="text"
  class="form-control"
  [(ngModel)]="model"
  [ngbTypeahead]="initializeTypeahead"

  [resultTemplate]="resultTemplate"
  [resultFormatter]="resultFormatter"
  [inputFormatter]="inputFormatter"
/>
