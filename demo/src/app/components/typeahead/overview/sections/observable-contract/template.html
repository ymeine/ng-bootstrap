<h5>Why the Observable?</h5>

<p>
  The Typeahead is designed around a single Observable, to which it subscribes in order to get an updated list of options and update its popup accordingly.
</p>

<p>
  The choice of the Observable is due to the nature of the data processing: often-updated and potentially asynchronous. <em>Observables</em> are designed mainly for this use case.
</p>

<p>
  It also bypasses the update of the parent template, to directly target the data of the Typeahead instance.
</p>



<h5>What is the Observable contract?</h5>

<p>
  The Typeahead expects to receive an Observable which spawns lists of items of any type.
</p>

<p>
  The elements of the list are formatted to be displayed in the popup, as well as in the input when an option is selected.
</p>

<p>
  Selecting an option commits the original item to the data model of the Typeahead.
</p>

<p>
  The table below shows what the Typeahead does depending on the content of the list and the state of its popup:
</p>
<table class="matrix">
  <thead>
    <tr>
      <th><span class="left">popup</span><span class="separator"></span><span class="right">results list</span></th>
      <th>not empty</th>
      <th>empty</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>closed</th>
      <td>open the popup, fill with the list</td>
      <td>do nothing</td>
    </tr>
    <tr>
      <th>open</th>
      <td>update the popup with the list</td>
      <td>close the popup</td>
    </tr>
  </tbody>
</table>



<h5>How to set up the Observable?</h5>

<p>
  The Typeahead uses a directive Input to pass a callback that it will call and expect the Observable to be returned from.
</p>

<p>
  On the template side, the property used by the Typeahead to instantiate its directive is the one used to pass the input callback:
</p>

<ngbd-code [lang]="snippets.observableSetup.template.language" [code]="snippets.observableSetup.template.code" [highlightedLines]="snippets.observableSetup.template.highlightedLines"></ngbd-code>

<p>
  On the component side, the latter defines this aforementioned callback, which returns the Observable — we will detail this below, just remember it is supposed to spawn lists of items:
</p>

<ngbd-code [lang]="snippets.observableSetup.component.language" [code]="snippets.observableSetup.component.code" [highlightedLines]="snippets.observableSetup.component.highlightedLines"></ngbd-code>



<h5>The basic Observable chain</h5>

<p>
  In this basic example we will simply use a statically defined and synchronously available set of data — color names:
</p>

<ngbd-code [lang]="snippets.data.language" [code]="snippets.data.code" [highlightedLines]="snippets.data.highlightedLines"></ngbd-code>

<p>
  The callback used to provide the Observable to the Typeahead receives a single argument: another Observable spawning strings based on the <code>input</code> event of the Typeahead.
</p>

<ngbd-code [lang]="snippets.observable.mapping.language" [code]="snippets.observable.mapping.code" [highlightedLines]="snippets.observable.mapping.highlightedLines"></ngbd-code>

<p>
  We return all the colors when the search term is empty, otherwise we return all the colors starting with it. <ngbd-overview-operator-popup name="map"></ngbd-overview-operator-popup> is the perfect operator to transform an input to an output: it's a 1:1 transformation — 1 value in, 1 value out.
</p>

<p>
  Basic Typeahead will still require basic processing like debouncing, and more advanced use cases will require further usage of the Observables.
</p>
