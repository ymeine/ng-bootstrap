<h5>Why the Observable?</h5>

<p>
  The Typeahead is designed around a single Observable, to which it subscribes in order to get an updated list of options and update its popup accordingly.
</p>

<p>
  The choice of the Observable is due to the nature of the data processing: often updated and potentially asynchronous. Observables are designed mainly for this use case.
</p>

<p>
  It also allows to bypass the update of the parent template, to directly target the data of the Typeahead instance.
</p>



<h5>What is the Observable contract?</h5>

<p>
  The Typeahead expects to receive an Observable which spawns lists of items of any type.
</p>

<p>
  The elements of the list are formatted to be displayed in the popup, as well as in the input when an option is selected.
</p>

<p>
  Selecting an option commits the original item to the data model of the Typeahead. If your option items can be converted to proper strings out of the box, you don't <em>need</em> to customize the formatting (but you still can). Otherwise, you will have to (more on that in below section).
</p>

<p>
  The table below shows what the Typeahead does with its popup depending on the content of the spawned options list and the current state of its popup:
</p>
<table class="matrix">
  <thead>
    <tr>
      <th><span class="left">popup</span><span class="separator"></span><span class="right">options list</span></th>
      <th>not empty</th>
      <th>empty</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>closed</th>
      <td>open the popup, fill with the list</td>
      <td>do nothing</td>
    </tr>
    <tr>
      <th>open</th>
      <td>update the popup with the list</td>
      <td>close the popup</td>
    </tr>
  </tbody>
</table>



<h5>How to set up the Observable?</h5>

<p>
  The directive property you use to instantiate a Typeahead on an input is used to pass the callback the Typeahead needs. It will call it, and expect an Observable to be returned from it.
</p>

<p>
  This is how it looks on the template side:
</p>

<ngbd-code [lang]="snippets.observableSetup.template.language" [code]="snippets.observableSetup.template.code" [highlightedLines]="snippets.observableSetup.template.highlightedLines"></ngbd-code>

<p>
  On the component side, you must define this callback and return the Observable:
</p>

<ngbd-code [lang]="snippets.observableSetup.component.language" [code]="snippets.observableSetup.component.code" [highlightedLines]="snippets.observableSetup.component.highlightedLines"></ngbd-code>



<h5>The basic Observable chain</h5>

<p>
  In this basic example we will simply use a statically defined and synchronously available set of data â€” color names:
</p>

<ngbd-code [lang]="snippets.data.language" [code]="snippets.data.code" [highlightedLines]="snippets.data.highlightedLines"></ngbd-code>

<p>
  The callback used to provide the Observable to the Typeahead receives a single argument: another Observable. It spawns:
</p>
<ul>
  <li>what: strings corresponding to the current content of the input</li>
  <li>when: on the <code>input</code> event of the input</li>
</ul>

<p>
  You can therefore use it as a search term and apply filtering for instance:
</p>

<ngbd-code [lang]="snippets.observable.mapping.language" [code]="snippets.observable.mapping.code" [highlightedLines]="snippets.observable.mapping.highlightedLines"></ngbd-code>

<p>
  We return all the colors when the search term is empty, otherwise we return all the colors starting with it.
</p>

<p>
  Basic Typeahead will still require basic processing like debouncing, search term length threshold, etc., while more advanced use cases will require even further usage of the Observables.
</p>
